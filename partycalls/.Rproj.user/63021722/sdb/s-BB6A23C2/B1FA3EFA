{
    "collab_server" : "",
    "contents" : "#' Find symmetric difference\n#'\n#' The symmetric difference is defined as the set difference between the\n#' union of two sets and the intersection of those sets.\n#' @param x vector\n#' @param y vector\n#' @return vector of elements in either x or y but not both\nsymdiff <- function(x, y)\n{\n  sort(setdiff(base::union(x, y), base::intersect(x, y)))\n}\n\n#' Regress a single roll call on party indicator and ideal points\n#'\n#' To be used inside a call to code_party_calls_1step\n#' @param .SD subset of a data.table of roll call votes, with a column for party\n#' labels\n#' @return list of coefficient, standard error, t value, and p value for the\n#' coefficient on party\ntest_rollcall <- function(.SD)\n{\n  if (mean(.SD[, y], na.rm = TRUE) %in% c(0:1, NaN) |\n      length(unique(.SD[!is.na(y) & party %in% c(\"D\", \"R\"), party])) == 1L) {\n    list(b = 0, se = 0, t = Inf, p = NA_real_)\n  } else {\n    m <- lm(y ~ party + x, data = .SD)\n    suppressWarnings(summ <- summary(m)$coef[\"partyR\", ])\n    list(b = summ[\"Estimate\"], se = summ[\"Std. Error\"],\n         t = summ[\"t value\"], p = summ[\"Pr(>|t|)\"])\n  }\n}\n\n#' Run one step of the party calls algorithm\n#'\n#' To be used inside a call to code_party_calls\n#' @param rc a rollcall object\n#' @param DT data.table with votes and party indicators\n#' @param noncalls indices for non-party calls from last run\n#' @return vector of indices for non-party calls\ncode_party_calls_1step <- function(rc, DT, noncalls)\n{\n  rc1 <- rc\n  rc2 <- rc\n  rc1$votes <- rc$votes[, noncalls]\n  rc2$votes <- rc$votes[, -noncalls]\n  rc1$m <- ncol(rc1$votes)\n  rc2$m <- ncol(rc2$votes)\n  p <- makePriors(rc1$n, rc1$m, 1)\n  s <- getStarts(rc1$n, rc1$m, 1)\n  sink_target <- if (Sys.info()[[\"sysname\"]] == \"Windows\") {\n    \"NUL\"\n  } else {\n    \"/dev/null\"\n  }\n  sink(sink_target)\n  l <- binIRT(.rc = rc1, .starts = s, .priors = p,\n              .control = list(threads = 1, verbose = FALSE, thresh = 1e-6))\n  sink()\n  unlink(sink_target)\n  DT$x <- l$means$x\n  regs <- DT[party %in% c(\"D\", \"R\"), test_rollcall(.SD), .(vt)]\n  pvals <- regs$p\n  pvals[is.na(pvals)] <- 1\n  pvals\n  ok <- pvals > .05\n  which(ok)\n}\n\n#' Run the party calls classifier\n#'\n#' Use the iterative algorithm that (1) predicts ideal points based on last\n#' iteration's non-party calls, (2) runs regressions of roll call vote on\n#' ideal points and party, (3) classify new iteration of non-party calls as\n#' votes for which the p value on party is > .05.\n#' @param rc a rollcall object\n#' @return rollcall object with record of classification algorithm and\n#' list of classified party calls\n#' @import data.table emIRT pscl\n#' @export\ncode_party_calls <- function(rc)\n{\n  rc <- pscl::dropRollCall(rc, dropList = alist(dropLegis = state == \"USA\"))\n  rc <- emIRT::convertRC(rc, type = \"binIRT\")\n  DT <- CJ(vt = colnames(rc$votes), mc = rownames(rc$votes), sorted = FALSE)\n  DT$y <- as.vector(rc$votes)\n  DT$party <- rc$legis.data$party\n  DT[y %in% c(0, 9), y:= NA]\n  DT[y == -1, y:= 0]\n  noncalls <- sample(rc$m, floor(.5 * rc$m))\n  switched_votes <- seq_len(rc$m)\n  match_counter <- 0\n  counter <- 0\n  record_of_coding <- list()\n  record_of_pvals <- list()\n  while (counter <= 15 | (counter < 150 & match_counter < 10)) {\n    counter <- counter + 1\n    record_of_coding[[counter]] <- noncalls\n    old_noncalls <- noncalls\n    old_switched_votes <- switched_votes\n    pvals <- code_party_calls_1step(rc, DT, noncalls)\n    record_of_pvals[[counter]] <- pvals\n    noncalls <- which(pvals > .05)\n    calls <- setdiff(seq_len(rc$m), old_noncalls)\n    n_random_switches <- floor(rc$m * .2 * max(0, 1 - counter / 50) ^ 2)\n    if (n_random_switches > 0) {\n      calls_to_switch <- sample(calls, n_random_switches)\n      noncalls_to_switch <- sample(noncalls, n_random_switches)\n      calls_to_keep <- setdiff(calls, calls_to_switch)\n      noncalls_to_keep <- setdiff(noncalls, noncalls_to_switch)\n      calls <- c(calls_to_keep, noncalls_to_switch)\n      noncalls <- c(noncalls_to_keep, calls_to_switch)\n    }\n    switched_votes <- symdiff(noncalls, old_noncalls)\n    if (length(switched_votes) <= 5) {\n      match_counter <- match_counter + 1\n    } else {\n      match_counter <- 0\n    }\n    cat(\"Iteration\", counter, \"had\", length(switched_votes), \"out of\", rc$m,\n        \"switched votes\\n\")\n  }\n  rc$party_calls <- seq_len(rc$m)[-noncalls]\n  rc$record_of_coding <- record_of_coding\n  rc$record_of_pvals <- record_of_pvals\n  rc\n}\n\nget_gray_votes <- function(record_of_coding)\n{\n  tail_diff <- symdiff(tail(record_of_coding, 2)[[2]],\n                       tail(record_of_coding, 2)[[1]])\n  # if (length(tail_diff) == 0L) {\n  #   gray_votes <- NULL\n  # } else {\n  record_of_coding <- tail(record_of_coding, 10)\n  all_votes_ever_classied_as_calls <- Reduce(union, record_of_coding)\n  all_votes_always_classied_as_calls <- Reduce(intersect, record_of_coding)\n  gray_votes <- setdiff(all_votes_ever_classied_as_calls,\n                        all_votes_always_classied_as_calls)\n  paste(\"Vote\", gray_votes)\n  # }\n}\n\n\n#' Make dataset at level of senator/year\n#'\n#' For a single congress, assemble data for analysis\n#' @param congress congress ID number\n#' @param roll_calls_object_list rc a list of rollcall objects with classified\n#' party calls\n#' @return data.table with party-free ideal points\n#' @import data.table emIRT pscl\n#' @export\nmake_member_year_data <- function(congress, roll_calls_object_list)\n{\n  rc <- roll_calls_object_list[[paste0(\"hou\", congress)]]\n  ld <- rc$legis.data\n  ld$mc <- rownames(ld)\n  setDT(ld)\n  votes <- rc$votes\n  votes <- melt(votes)\n  setDT(votes)\n  setnames(votes, c(\"mc\", \"vote_id\", \"vote\"))\n  votes <- merge(votes, ld, by = \"mc\")\n  gray_vote_ids <- get_gray_votes(rc$record_of_coding)\n  party_call_vote_ids <- setdiff(paste(\"Vote\", rc$party_calls), gray_vote_ids)\n  noncall_vote_ids <- setdiff(paste(\"Vote\", setdiff(1:rc$m, rc$party_calls)),\n                              gray_vote_ids)\n  votes[, gray := as.numeric(vote_id %in% gray_vote_ids)]\n  votes[, party_yea_rate := sum(vote == 1) / sum(vote %in% c(1, -1)),\n        .(vote_id, party)]\n  votes[, party_pos :=\n          as.numeric(party_yea_rate > .5) - as.numeric(party_yea_rate < .5)]\n  votes[, party_call := as.numeric(vote_id %in% party_call_vote_ids)]\n  votes[, noncall := as.numeric(vote_id %in% noncall_vote_ids)]\n  member_year_data <- votes[vote %in% c(1, -1) & party_pos != 0,\n                            .(\n                              responsiveness_party_calls =\n                                mean(vote[party_call == 1] == party_pos[party_call == 1]),\n                              responsiveness_noncalls =\n                                mean(vote[noncall == 1] == party_pos[noncall == 1]),\n                              n_party_calls = sum(party_call == 1),\n                              n_noncalls = sum(noncall == 0)\n                            ), mc]\n  member_year_data <- merge(member_year_data, ld, by = \"mc\")\n  rc_noncalls <- rc\n  rc_noncalls$votes <- rc_noncalls$votes[, noncall_vote_ids]\n  rc_noncalls$m <- ncol(rc_noncalls$votes)\n  p <- makePriors(rc_noncalls$n, rc_noncalls$m, 1)\n  s <- getStarts(rc_noncalls$n, rc_noncalls$m, 1)\n  sink_target <- if (Sys.info()[[\"sysname\"]] == \"Windows\") {\n    \"NUL\"\n  } else {\n    \"/dev/null\"\n  }\n  sink(sink_target)\n  fitted_emIRT <- binIRT(.rc = rc_noncalls, .starts = s, .priors = p,\n                         .control = list(threads = 1, verbose = FALSE, thresh = 1e-6))\n  sink()\n  unlink(sink_target)\n  ideal <- as.data.frame(fitted_emIRT$means$x)\n  ideal$mc <- rownames(ideal)\n  setDT(ideal)\n  setnames(ideal, c(\"pf_ideal\", \"mc\"))\n  member_year_data <- merge(member_year_data, ideal, by = \"mc\")\n  member_year_data$congress <- congress\n  is_orientation_correct <- member_year_data[party == \"R\", mean(pf_ideal)] >\n    member_year_data[party == \"D\", mean(pf_ideal)]\n  if (!is_orientation_correct) {\n    member_year_data[, pf_ideal := -pf_ideal]\n  }\n  member_year_data[, pf_ideal := 5 + pf_ideal - mean(pf_ideal)]\n  member_year_data[, pf_ideal := pf_ideal / sd(pf_ideal)]\n  member_year_data[, dist_from_floor_median := abs(pf_ideal - median(pf_ideal))]\n  member_year_data[party == \"D\", dist_from_party_median := abs(pf_ideal - median(pf_ideal))]\n  member_year_data[party == \"R\", dist_from_party_median := abs(pf_ideal - median(pf_ideal))]\n  member_year_data[, ideological_extremism := abs(pf_ideal - 5)]\n  member_year_data[party == \"D\", ideological_extremism := -pf_ideal]\n  list(member_year_data = member_year_data, fitted_emIRT = fitted_emIRT)\n}\n",
    "created" : 1475860516777.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4077189241",
    "id" : "B1FA3EFA",
    "lastKnownWriteTime" : 1475860561,
    "last_content_update" : 1475860561790,
    "path" : "~/GitHub/partycalls/partycalls/dev/adjust-functions.R",
    "project_path" : "dev/adjust-functions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}